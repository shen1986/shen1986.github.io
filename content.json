{"meta":{"title":"小沈的个人博客","subtitle":"发表文章，自己的想法，学习分享","description":"用来总结自己学过的东西","author":"小沈","url":"http://shenxf.top","root":"/"},"pages":[{"title":"关于我","date":"2019-03-04T06:04:05.000Z","updated":"2019-03-22T03:11:09.173Z","comments":true,"path":"about/index.html","permalink":"http://shenxf.top/about/index.html","excerpt":"","text":"我的联系方式 QQ: 185693240 邮箱: shenxf1986@qq.com 地点: 上海 擅长: 前端 nodejs,react,vue,angular java 欢迎大家给我留言"}],"posts":[{"title":"JavaScript_可维护_编写可维护的JavaScript","slug":"20190610-MaintainableJavaScript","date":"2019-06-10T06:15:12.000Z","updated":"2019-06-10T06:16:46.862Z","comments":true,"path":"2019/06/10/20190610-MaintainableJavaScript/","link":"","permalink":"http://shenxf.top/2019/06/10/20190610-MaintainableJavaScript/","excerpt":"","text":"边看书边做笔记，这个仓库主要是参照《编写可维护的JavaScript》这本书，来总结自己的学习笔记。只是自己的总结，和书本不一样，如果觉得不错，你可以购买这本书自己研究。书本还涉及到JSLint，JSHint中的区别。实例代码从哪里取材，各种组织或公司的代码风格，并进行比较以及总结。对于某些写法的观点有时有些模棱两可，我自己的总结没有这些东西，更偏向与自己怎么写。 最后，我写这篇东西也不容易，如果感觉不错，请点Star,谢谢大家。 编程风格 基本的格式化 缩进层级 语句结尾 行的长度 换行 空行 命名 变量和函数 常量 构造函数 直接量 字符串 数字 null undefined 对象直接量 数组直接量 注释 单行注释 多行注释 使用注释 难以理解的代码 可能被误认为错误的代码 游览器特性hack 文档注释 语句和表达式 花括号的对齐方式 块语句的间隔 switch语句 缩进 case语句的“连续执行” default with语句 for循环 for-in循环 变量、函数和运算符 变量声明 函数声明 函数调用间隔 立即调用的函数 严格模式 相等 缩进层级 缩进层级非常重要，弄的不好，容易造成很多误解。下这段代码 (为了演示,.这里故意修改了示例代码的缩进〕。 12345678910111213if (wl &amp;&amp; wl.length) &#123; for (i = 0, 1 = wl.length; i &lt; 1; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r(p], s&#123;p]);&#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125;&#125; 快速读憧这段代码井不容易。 这里的缩进并不统一,一眼看去 else 是对应到第 1行的if语句。 但实际上这个 else 和代码第 5行的if语句相对应。 1234567891011121314if (wl &amp;&amp; wl.length) &#123; for (i = 0, 1 = wl.length; i &lt; 1; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125;&#125; 有两种主张 使用制表符进行缩进 就是[tab]进行缩进 使用空格进行缩进 一般是以4个空格进行缩进 以上两种方法都可以，但是不要两种方法混用。 返回顶部 语句结尾 在javascript里面可以不以分号结尾。分析器会自动在结尾加上分号。 但是不推荐这种做法。 1234567891011121314151617// 原始代码function getData()&#123; return &#123; title: \"Maintainable JavaScript\", author: \"Nicholas C. Zakas\" &#125;&#125;// 分析器会将它理解成function getData()&#123; return; &#123; title: \"Maintainable JavaScript\", author: \"Nicholas C. Zakas\" &#125;;&#125; 以上面的例子来讲，函数将返回一个undefined，这不是我们要的结果。虽然可以将 { 放到 return 之后，但是分析器的判断比较复杂，不能保证我们能考虑到所有的情况。 所有我们应该更加倾向于使用它们，而不是省略它们。 上面是书的作者的看法，我确实看到一种风格是结尾一律不加分号，这种写法要求在语句是以[,(,`开头的时候，在前面加上分号。 而且推荐这种做法的人认为，不加分号反而不容易出错。像类似于上面的错误是不会被忽略到上线阶段的，当你创建了一个方法，没有得到你想要的结果，应该在开发的时候就立即被发现了。 就算使用了加了分号的规范，有时也会因为不小心而漏掉（用检测工具的没有这个问题） 最后，使用的第三方代码不一定是加分号的风格。有可能还是不得不在第一个位置加上分号。 12345678910111213// 这些语句与上一句没有分号的语句连接的话会直接报错，所以必须加分号;[1,2,3].foreach(function()&#123; // 处理内容&#125;);`shenxf$&#123;nickname&#125;`.length// 很多代码都习惯于在圆括号之前加一个分号，这是由于之前引入的代码可能有漏了分号的情况，// 为了以防万一，都会有类似于下面的代码。;(function()&#123; // 处理内容。&#125;)() 我比较喜欢不省略分号，如果想采用省略分号的规范，切记在[,(,`之前加上分号。 返回顶部 行的长度 如果一行的内容太长，编辑窗口就会出现滚动条。这样不利于我们查看代码，也比较变扭。我们应该规定我们一行的长度不要超过80个字符。超过80个字符应该折行。这是因为很多编辑器是在80个字符以后出现滚动条 返回顶部 换行 当一行的长度太长我们就会进行折行。通常要在运算符后面换行，这是因为分析器不会再运算符后面自动加分号。不容易出错。 1234567891011// 好的做法：在运算符后面换行。 第二行追加二个缩进callAFunction(document, element, window, \"some string value\", true, 123, navigator);// 不好的做法第二行只有一个缩进callAFunction(document, element, window, \"some string value\", true, 123, navigator);// 不好的做法运算符之前换行了callAFunction(document, element, window, \"some string value\", true, 123 , navigator); 为什么要二个缩进 12345if (isLeapYear &amp;&amp; isFebruary &amp;&amp; day &amp;&amp; day ==29 &amp;&amp; itsYourBirthdady &amp;&amp; noPlans) &#123; waitAnotherFourYears();&#125; 从上面的代码可以看出，二个缩进正好和条件内部语句的一个缩进错开，这样更容易阅读。 但是有一个例外。在赋值语句后面的第二行位置最好要对齐 12var result = something + anotherThing + yetAnotherThing + someThingElse + anotherSomethingElse; 返回顶部 空行 空行常常被忽略，代码看起来应该像一段一段可读的代码，而不是全部糅合在一块。拿缩进层级的例子来说 12345678910111213if (wl &amp;&amp; wl.length) &#123; for (i = 0, 1 = wl.length; i &lt; 1; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125;&#125; 给这段代码加上空行 12345678910111213141516if (wl &amp;&amp; wl.length) &#123; for (i = 0, 1 = wl.length; i &lt; 1; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125;&#125; 这样看上去能够更加流畅的阅读，一般来讲下面的场景添加空行是不错的注意 在方法之间。 在方法中的局部变量和第一条语句之间。 在多行或则单行注释之前。 在方法的逻辑片段之间插入空行，提高可读性。 返回顶部 命名 JavaScript语言核心是ECMAScript，遵照了驼峰式大小写命名法（这个太有名了我就不解释了） 一般是遵循语言核心所采用的命名规范，因此大部分JavaScript程序员使用驼峰命名法给变量和函数命名。 返回顶部 变量和函数 变量的命名前缀应该是名词，这能后和函数的命名规则区分开，函数应该以动词来做前缀。 123456789101112131415161718// 好的写法var count = 10;var myName = \"shenxf\";var found = true;// 不好的写法: 变量看起来像函数var getCount = 10;var isFound = true;// 好的写法function getName() &#123; return myName;&#125;// 不好的写法function theName() &#123; return myName;&#125; 命名应该要尽量短小精干，例如，count，length和size一看就知道是数字类型，name，title，和message一看就知道是字符串类型 i，j，k通常在循环处理中使用。 要经量避免写无意义的命名。 对于方法的命名，第一个单词应该是动词。下面是一些常见的约定 动词 含义 can 函数返回一个布尔值 has 函数返回一个布尔值 is 函数返回一个布尔值 get 函数返回一个非布尔值 set 函数用来保存一个值 按照上面的写法，可读性会很好 12345678if (isEnabled()) &#123; setName(\"shenxf\");&#125;if (getName() === \"shenxf\") &#123; doSomething();&#125; 返回顶部 常量 在ECMAScript6之前，JavaScript没有真正常量的概念。为了区分普通的变量和常量，用类似于C语言方法来命名，用大写字母和下划线来命名，下划线是用来分隔单词的。 12var MAX_COUNT = 10;var URL = \"http://shenxf.top\"; 来看一下代码 123if (count &lt; MAX_COUNT) &#123; doSomething();&#125; 返回顶部 构造函数 构造函数遵照大驼峰命名法。主要是为了和函数与变量的命名法进行区分。 12345678910// 好的做法function Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; alert(this.name);&#125;var me = new Person(\"shenxf\"); 这样写可以快速的发现问题，看一下下面的代码 12var me = Person(\"shenxf\"); // 这里缺少了newvar you = getPerson(\"xx\"); 返回顶部 直接量 JavaScript里面的原始值包括：字符串、数字、布尔值、null和undefined。也包含对象和数组的直接量。 其中只有布尔值是自解释的，其他的多少要考虑下如何能准确地表达其中的含义。 返回顶部 字符串 这里原书的作者提出可以用双引号和单引号。 123// 下面都是合法的javascript代码var name = \"shenxf says, \\\"Hi.\\\"\";var name = 'shenxf says, \"Hi.\"'; 书的作者经常使用Java，Java是用双引号来表示字符串。所以作者推荐使用双引号，因为可以和Java语言保持一致。 我个人推荐使用单引号，本人之前使用的很多编码规范插件都是以单引号来声明变量的。我已经习惯了，所以我推荐使用单引号。不管使用哪一种，自己的代码风格保持一致我觉得就可以了。 当字符串换行的时候，应该使用运算符来连接。 1234567// 不好的写法var longString = \"Here's the story, of a man \\named Brady.\";// 好的写法var longString = \"Here's the story, of a man\" + \"named Brady.\"; 返回顶部 数字 直接给列子 123456789101112131415161718192021// 整数var count = 10;// 小数var price = 10.0;var price = 10.00;// 不推荐小数的写法：没有小数部分var pricee = 10.;// 不推荐小数的写法：没有整数部分var price = .1;// 不推荐的写法：八进制写法已经被弃用var num = 010;// 十六进制写法var num = 0xA2;// 科学计数法var num = 1e23; 不推荐写法的前两个感觉特别变扭，不知道是刻意写的还是漏掉的。为了避免歧义，所以不推荐。 八进制的写法也很容易产生歧义，很有可能被认为是整数10，其实是8,所以不推荐。 返回顶部 null null比较特殊经常和undefined混淆。 应该使用null的场景 用来初始化一个变量，这个变量可能被赋值为一个对象 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象 当函数的参数期望是对象时，用作参数传入 当函数的返回值期望是对象时，用作返回值传出 不应该使用null的场景 不要使用null来检测是否传入了某个参数 不要用null来检测一个未初始化的变量 例子 12345678910111213141516171819202122232425262728293031// 好的用法var person = null;// 好的用法function getPerson() &#123; if (condition) &#123; return new Person(\"shenxf\"); &#125; else &#123; return null; &#125;&#125;// 好的用法var person = getPerson();if (person !== null) &#123; doSomething();&#125;// 不好的写法：用来和未初始化的变量进行比较var person;if (person != null) &#123; doSomething();&#125;// 不好的写法：检测是否传入了参数function doSomething(arg1, arg2, arg3, arg4) &#123; if (arg4 != null) &#123; doSomethingElse(); &#125;&#125; 理解null最好的方法是把它理解成一个占位符 返回顶部 undefined 最让人困惑的是 null == undefined 的结果是true,然而，这2个值的用法各不相同。 那些没有被初始化的变量都有一个初始值，即undefined,表示这个变量等待被赋值。 123// 不好的写法var person;console.log(person === undefined); //true 虽然这是正常的代码，但是我们应该经量避免undefined. 因为undefined有很多让人费解的地方，比如typeof 1234// foo未被声明var person;console.log(typeof person); // \"undefined\"console.log(typeof foo); // \"undefined\" 这段代码看似没什么，但是在某些场景下面有天壤之别（在语句中foo会报错，而person则不会） 通过禁止使用特殊值undefined,可以使得typeof出来的结果只有一种可能出现undefined。那就是变量未声明的时候。 123// 好的做法var person = null;console.log(person === null); // true typeof null值返回的是Object,这样可以避开undefined,这样就区分开了。 返回顶部 对象直接量 有直接量的东西，最好不要先创建然后再赋值。 1234// 不好的写法var book = new Object();book.title = \"shenxfsbook\";book.author = \"shenxf\"; 直接量可以高效的完成非直接量相同的任务。 当定义直接量的时候，第一行包含左花括号，每一个属性的名值对都独占一行，并保持一个缩进，最后花括号也独占一行 12345// 好的写法var book = &#123; title: \"shenxfsbook\", author: \"shenxf\"&#125;; 返回顶部 数组直接量 和对象的直接量类似，不建议使用非直接量。 1234567// 不好的写法var colors = new Array(\"red\", \"green\", \"blue\");var numbers = new Array(1, 2, 3, 4);// 好的写法var colors = [\"red\", \"green\", \"blue\"];var numbers = [1, 2, 3, 4]; 返回顶部 单行注释1// 这是一句单行注释 双斜杠后面最好预留一个空格 单行注释 有3中使用方法 独占一行注释，用来解释下一行代码，这行注释之前总是有一个空行，且缩进层级和下一行代码保持一致 在代码行的尾部的注释。代码结束到注释之间至少有一个缩进。注释（包括之前的代码部分）不应当超过单行的最大字符数限制，如果超过了，就应该将这行注释放在代码行上方。 被注释掉的大段代码（编译器自带的批量注释多行代码） 单行注释不应该用于多行，除非是注释的大段代码。 123456789101112131415161718192021222324252627282930313233343536373839// 好的写法if (condition) &#123; // 如果代码执行到这里，则表示通过了左右的安全性检查 allowed();&#125;// 不好的写法：注释之前没有空行if (condition) &#123; // 如果代码执行到这里，则表示通过了左右的安全性检查 allowed();&#125;// 不好的写法：错误的缩进if (condition) &#123;// 如果代码执行到这里，则表示通过了左右的安全性检查 allowed();&#125;// 好的写法var result = something + somethingElse; // somethingElse不应当取值为null// 不好的写法：代码和注释之间没有间隔var result = something + somethingElse;// somethingElse不应当取值为null// 好的写法// if (condition) &#123;// dosomething();// thenDoSomethingElse();// &#125;// 不好的写法:这里应当用多行注释// 接下来的这段代码非常难，那么，让我详细的解释下// 这段代码首先判断条件是否为真// 。。。。。。。if (condition) &#123; // 如果代码执行到这里，则表示通过了左右的安全性检查 allowed();&#125; 返回顶部 多行注释 合法的多行注释 1234567/* 我的注释 *//* 另一段注释这个注释包含2行 *//*又是一段注释这段注释同样包含2行*/ 这些注释都是合法但是看得不清晰，推荐使用类似于java的注释方法 第一是/*,最后一行是*/，当中每一行都以*开头，且空开一个空格 1234/* * 另一段注释 * 这个注释包含2行 */ 多行注释应该和单行注释一样注释之前要有空行，注释用来说明下面行的代码，并与下一行保持同样的缩进 123456789101112131415161718192021222324252627282930313233343536373839// 好的写法if (condition) &#123; /* * 如果代码执行到这里 * 说明通过了所有安全性检查 */ allowed();&#125;// 不好的写法：注释之前无空行if (condition) &#123; /* * 如果代码执行到这里 * 说明通过了所有安全性检查 */ allowed();&#125;// 不好的写法：星号之后没有空格if (condition) &#123; /* *如果代码执行到这里 *说明通过了所有安全性检查 */ allowed();&#125;// 不好的写法：错误的缩进if (condition) &#123;/* * 如果代码执行到这里 * 说明通过了所有安全性检查 */ allowed();&#125;// 不好的写法：代码尾部不要用多行注释var result = something + somethingElse; /*somethingElse不应当取值为null*/ 返回顶部 使用注释 代码不够清晰时应该添加注释，代码很明了的时候不应该添加注释，有点画蛇添足。 123456789// 不好的写法：注释并没有提供有价值的信息// 初始化countvar count = 10;// 好的写法// 改变这个值可能会使它变成青蛙var count = 10; 因此，添加注释的原则是需要让代码变的更清晰的时候。 返回顶部 难以理解的代码 难以理解的代码应该添加注释 123456789101112131415161718192021222324252627282930313233// 好的写法if (mode) &#123; /* * 当 mode 为2时 * 用来执行原型合并的操作。。。。 * 。。。。 */ if (mode === 2) &#123; Y.mix(receiver.prototype, supplier.prototype, overwrite, whitelis, 0, merge); &#125; /* * 根据模式的类型。。。 * 。。。。 */ from = mode === 1 || mode === 3 ? supplier.prototype : supperlier; to = mode === 1 || mode === 4 ? receiver.prototype : receiver; /* * ....... * ...... */ if (!from || !to) &#123; from = supperlier; to = receiver; &#125;&#125; else &#123; from = supplier; to = receiver;&#125; 返回顶部 可能被误认为错误的代码 团队里面会有一些好心人，自主的把一个看上去错误代码改正，但是这段错误的往往并不是错误的源头 修改了这段代码会导致另外的bug 1234567while (element &amp;&amp; (element = element[asix])) &#123; // 赋值操作 if( (all || element[TAG_NAME]) &amp;&amp; (!fn || fn(element)) ) &#123; return element; &#125;&#125; 在这里例子里面作者写明了他是赋值操作，虽然这不是一种标准用法，检测工具可能会检测出问题 很容易被误解成一个错误。这种注释就表明作者是有意为之。从而避免了不必要的误解。 返回顶部 游览器特性hack 为了要兼容低版本的游览器，JavaScript程序员往往会写一些“可能被误认为错误的代码“。 12345678910111213141516var ret = false;if ( !needle || !element || !needle[NODE_TYPE] || !element[NODE_TYPE]) &#123; ret = false;&#125; else if (element[CONTAINS]) &#123; // 如果needle不是ELEMENT_NODE时，IE和Safari下会有错误 if (Y.UA.opera || needle[NODE_TYPE] === 1) &#123; ret = element[CONTAINS](needle); &#125; else &#123; ret = Y_DOM._bruteContains(element, needle); &#125;&#125; else if (element[COMPARE_DOCUMENT_POSITION]) &#123; // gecko if (element === needle || !!(element[COMPARE_DOCUMENT_POSITION](needle) &amp; 16)) &#123; ret = true &#125;&#125; 第六行有一段重要的注释，尽管IE和Safari中都有内置的方法contains(),但是needle不是一个元素是，这个方法会报错 所以只有当浏览器是Opera的时候才能用这个方法。这里说明了为什么要一个if语句。这样不会被别人误改动，而且以后浏览器要做相应的兼容性改动是也能快速的定位到这段代码，对自己的维护也是有好处的。 返回顶部 文档注释 虽然不是JavaScript的组成部分但是现在广泛的被运用，一般文档注释有多种格式，最流行的是源于JavaDoc文档格式： 多行注释以单斜线双星号/**开始，接下来是描述信息，其中@符号来表示一个或多个属性。 1234567891011121314151617181920/**返回一个对象，这个对象包含被提供对象的所有属性。后一个对象的属性会覆盖前一个对象的属性。传入一个单独对象。。。。@method merge@param &#123;Object&#125; 被合并的一个或多个对象@param &#123;Object&#125; 一个新的合并后的对象**/Y.merge = function() &#123; var args = arguments, i = 0, len = args.length, result = &#123;&#125;; for (; i&lt;len; ++i) &#123; Y.mix(result, args[i], true); &#125; return result;&#125;; 你应当确保对如下的内容添加注释 所有的方法 应当对方法，期望的参数和可能的返回值添加注释描述。 所有的构造函数 应当对自定义类型和期望的参数添加注释描述。 所有包含文档化方法的对象 如果一个对象包含一个或多个附带文档注释的方法，那么这个对象也应当适当地针对文档生成工具添加文档注释。 当然，注释的详细格式和用法最终还是由你所选择的文档生成工具决定的。 返回顶部 花括号的对齐方式 有2中风格 第一个风格是，将左括号放置在第一句代码的末尾 这种风格来自java12345if (condition) &#123; doSomething();&#125; else &#123; doSomethingElse();&#125; 第二种风格是将左括号放置于块语句首行的下一行。 12345678if (condition)&#123; doSomething();&#125;else&#123; doSomethingElse();&#125; 这种风格是C#的风格，这种写法会导致，自动插入分号位置错误，所以JavaScript里不推荐用这种风格。 返回顶部 块语句的间隔 有三种主要的风格 第一种风格，在语句名，圆括号和左花括号之间没有空格间隔。 这种风格可读性不好。123if(condition)&#123; doSomething();&#125; 第二种风格,在左圆括号之前和右圆括号之后各添加一个空格 这种风格最流行。123if (condition) &#123; doSomething();&#125; 第三种风格，在左圆括号后和右圆括号前各添加一个空格 这种写法可读性最高。123if ( condition ) &#123; doSomething();&#125; 本人和书的作者一样比较推荐第二种风格。 返回顶部 switch语句 JavaScript中的switch语句的行为和在其他语言中是不一样的：switch语句中可以使用任意类型值，任何表达式都可合法地用于case从句。但在其他语言中则必须使用原始值和常量。 返回顶部 缩进 很多人用java的风格 12345678910111213141516switch(condition) &#123; case \"first\": // 代码 break; case \"second\": // 代码 break; case \"third\": // 代码 break; default: // 代码&#125; 独特之处 每条case语句相对于switch关键字都缩进一个层级。 从第二条豫剧开始，每条case语句前后各有一个空行。 另一种风格 12345678910111213switch(condition) &#123;case \"first\": // 代码 break;case \"second\": // 代码 break;case \"third\": // 代码 break;default: // 代码&#125; 不同之处是case关键字与switch保持左对齐， 我和作者都喜欢java的风格。 返回顶部 case语句的“连续执行” case后面不加break，就会连续执行下面的条件，这个成为很多系统bug的原罪。 但是还是有许多人接受这种连续执行的编程方法。但是逻辑一定要写的清晰。 123456789101112131415switch(condition) &#123; // 明显的依次执行 case \"first\": case \"second\": // 代码 break; case \"third\": // 代码 /* fall through */ default: // 代码&#125; 前面2行代码是个很明显的连续执行，这是合理的。 third里面由于添加了注释，说明这是有意为之。这也是合理的。 返回顶部 default 比较有争论的议题是，是否需要default，很多人不论何时都不省略default，尽管它什么也不做。 123456789101112switch(condition) &#123; case \"first\": // 代码 break; case \"second\": // 代码 break; default: // default中没有逻辑&#125; 作者比较倾向于，没有默认行为，并且写了注释的情况下可以省略 1234567891011switch(condition) &#123; case \"first\": // 代码 break; case \"second\": // 代码 break; // 没有 default&#125; 这样即表明了没有默认行为，又省下了字节。 我比较喜欢第一种，你可以只写default:不写注释。这样也清楚的知道没有默认行为，以后要加默认行为的时候可以少写一行代码。其实2种方法都可以，就看你喜欢哪一种。 返回顶部 with语句 在没看这本书之前，我根本不知道这个东西，如果你和我一样，请跳过这一章（不知道也就不会用），这不是什么好东西。 1234567891011var book = &#123; title: \"shenxf javascrpt\", author: \"shenxf\"&#125;;var message = \" The book is \";with (book) &#123; message += title; message += \" by \" + author;&#125; 虽然写法上它可以让我们省略一些字节，但是这东西有坏处，我们很难分辨title和author出现在哪个位置，也难分辨出message到底是局部变量还是book的一个属性。从程序上来讲，JavaScript引擎和压缩工具无法对这段代码进行优化，应为它们无法猜出代码的真正含义。 返回顶部 for循环 for循环有两种，一种是传统的for循环，另外一种是for-in循环 12345var values = [ 1, 2, 3, 4, 5, 6, 7], i, len;for (i=0, len=values.length; i &lt; len; i++) &#123; process(values[i]);&#125; for循环中可以使用break和continue语句，相信大家肯定知道怎么用。 有一种风格中说不要用continue，用continue还不如用条件语句，逻辑更清晰。 1234567var values = [ 1, 2, 3, 4, 5, 6, 7], i, len;for (i=0, len=values.length; i &lt; len; i++) &#123; if (i !== 2) &#123; process(values[i]); &#125;&#125; 书的作者没有明确表态，我认为这个不至于，想用还是可以用的。这个语句本身是没有问题的。 返回顶部 for-in循环 相信大家都会用。for-in循环不仅仅遍历对象的实例属性，从原型链继承来的属性也会遍历。当遍历自定义对象的属性时往往会因为意外的结果而终止。因此，最好使用hasOwnProperty()方法来为for-in循环过滤出实例属性。 12345678var prop;for (prop in object) &#123; if (object.hasOwnProperty(prop)) &#123; console.log(\"Property name is \" + prop); console.log(\"Property value is \" + object[prop]); &#125;&#125; 一般都会加上hasOwnProperty，但是如果你就是想查找原型链，请加上注释。 123456var prop;for (prop in object) &#123; // 包含对原型链的遍历 console.log(\"Property name is \" + prop); console.log(\"Property value is \" + object[prop]);&#125; for-in循环是用来遍历对象的，请不要用它来遍历数组。 1234567// 不好的用法var values = [ 1, 2, 3, 4, 5 ], i;for (i in values) &#123; process(item[i]);&#125; 返回顶部 变量声明 声明会被提升到当前作用域顶部。 123456function doSomething() &#123; var result = 10 + value; var value = 10; return result;&#125; 上面代码的理解 123456789function doSomething() &#123; var result; var value result = 10 + value; value = 10; return result;&#125; 这个函数得出的结果是NaN值。 作者倾向的风格,把所有定义放在作用域开始部分，用逗号分隔，可以节省写var的字节。 1234567891011function doSomethingWithItems(items) &#123; var value = 10, result = value + 10, i, len; for (i=0, len=items.length; i &lt; len; i++) &#123; doSomething(items[i]); &#125;&#125; 返回顶部 函数声明 函数声明也会被javaScript引擎提前。 123456// 不好的写法doSomething();function doSomething() &#123; alert('Hello world!');&#125; javaScript会把代码解释为 12345function doSomething() &#123; alert('Hello world!');&#125;doSomething(); 我们应该先声明函数再使用 1234567891011121314function doSomethingWithItems(items) &#123; var i,len, value = 10, result = value + 10; function doSomething(item) &#123; // 代码逻辑 &#125; for (i=0, len=items.length; i &lt; len; i++) &#123; doSomething(items[i]); &#125;&#125; 另外，函数不应该出现在语句块之内。 1234567891011// 不好的写法if (condition) &#123; function doSomething() &#123; alert('hi'); &#125;&#125; else &#123; function doSomething() &#123; alert('Yo'); &#125;&#125; 因为函数的声明会被提前，所以不管这里的条件满足与否，第二个同名的函数会把第一个函数覆盖。所以上面的代码不会按照我们的意图来执行。 返回顶部 函数调用间隔12345678910// 好的写法doSomething(item);// 不好的写法：看起来像一个语句块doSomething (item);// 用来做对比的块语句while (item) &#123; // 代码逻辑&#125; 返回顶部 立即调用的函数123456789101112131415161718192021222324// 一般的写法var doSomething = function() &#123; // 函数体&#125;;// 不好的写法 : 被误解为函数的赋值，其实是被赋值为一个对象var value = function() &#123; // 函数体 return &#123; message: \"Hi\" &#125;&#125;();// 好的写法var value = (function() &#123; // 函数体 return &#123; message: \"Hi\" &#125;&#125;()); 返回顶部 严格模式 use strict 1234567891011// 不好的写法 - 全局严格模式\"use strict\"function doSomething() &#123; // 代码&#125;// 好的写法function doSomething() &#123; \"use strict\" // 代码&#125; 如果希望在多个函数中应用严格模式而不必谢很多行的话，可以使用立即执行函数 12345678910// 好的写法(function() &#123; \"use strict\" function doSomething() &#123; // 代码 &#125; function doSomethingElse() &#123; // 代码 &#125;&#125;)(); 为什么不要全局使用严格模式？ 全局使用严格模式的情况下，其他文件中的（非严格模式下的）代码很可能会报错。 返回顶部 相等 相等的时候会进行类型转换 123456// 比较数字5和字符串5console.log(5 == \"5\"); // true// 比较数字25和十六进制的字符串25console.log(25 == \"0x19\"); // true 发生强制转换的时候字符串会被转换为数字，类似使用Number()转换函数。它能正确转换十六进制的数字。所以第二个表达式是相等的。 布尔值和数字比较 12345678// 数字 1 和 trueconsole.log(1 == true); // true// 数字 0 和 falseconsole.log(0 == false); // true// 数字 2 和 trueconsole.log(2 == true); // false 如果其中一个是对象另一个不是，则会先调用valueOf()方法得到原始类型再进行比较，如果没有valueOf()，则调用toString()。 1234567var object = &#123; toString: function() &#123; return \"0x19\"; &#125;&#125;;console.log(object == 25); // true 根据ECMAScript标准规范的描述,null和undefined是相等的。 1console.log(null == undefined); // true 由于以上强制类型转换的原因，推荐不要使用==和!=，应当使用===和!==,它们不会类型转换只要类型不一样就返回false 12345678910111213141516171819202122232425262728293031323334// 比较数字5和字符串5console.log(5 == \"5\"); // trueconsole.log(5 === \"5\"); // false// 比较数字25和十六进制的字符串25console.log(25 == \"0x19\"); // trueconsole.log(25 === \"0x19\"); // false// 数字 1 和 trueconsole.log(1 == true); // trueconsole.log(1 === true); // false// 数字 0 和 falseconsole.log(0 == false); // trueconsole.log(0 === false); // false// 数字 2 和 trueconsole.log(2 == true); // falseconsole.log(2 === true); // falsevar object = &#123; toString: function() &#123; return \"0x19\"; &#125;&#125;;// 一个对象和25console.log(object == 25); // trueconsole.log(object === 25); // false// null和undefinedconsole.log(null == undefined); // trueconsole.log(null === undefined); // false 返回顶部","categories":[{"name":"文章","slug":"文章","permalink":"http://shenxf.top/categories/文章/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shenxf.top/tags/JavaScript/"},{"name":"可维护","slug":"可维护","permalink":"http://shenxf.top/tags/可维护/"}]},{"title":"seo学习","slug":"20190529-seoStudy","date":"2019-05-29T04:12:26.000Z","updated":"2019-05-29T04:13:37.785Z","comments":true,"path":"2019/05/29/20190529-seoStudy/","link":"","permalink":"http://shenxf.top/2019/05/29/20190529-seoStudy/","excerpt":"","text":"主要是运用到自己博客网站的seo, 做这个记录以免以后自己忘记。想到一点写一点。买关键字的朋友，就不要看了。写的不好请见谅，如有问题请联系。 关键字 网站seo三大要素 标题 这个网站权重最高的关键字,要好好考虑。 内页文章的关键字尽量不要和自己的标题重叠。如果内页的权重高于自己的主页就不好了。要避开标题。 关键字 仅次于标题的权重，一般最好不要超过30个。多了被K。也不要太少。 网站描述 用来描述网站的基本信息，当某人通过百度查询到你网站的时候，能够在百度查询结果中看到这些描述。描述写的好，能够增加一定的流量。 网站的内链和外链 外链保持在30左右最好，太多了也不好，而且外链的增长速度不能太快，否则会被百度K掉。通过查询百度快照， 每次快照更新后，增加几条外链是没有问题的。一下子增加30条，会被K。 内链要合理，一篇1000字文章保持10左右的内链是最好的，这样可以使蜘蛛在自己网站来回转圈。 蜘蛛在网站停留的时间越久，收录性越好。 更新带动器 主页一定要经常变动，一点不变动，蜘蛛就不会来了 没时间天天更新，怎么让他变动？ 最新文章，网站访问人数，随机推荐文章等。（找点理由让主页每天都有变动）写点随机函数什么的。 百度蜘蛛 用来爬取网站的内容，收录到百度里面。 它对于前端渲染的页面不是很友好（比如：vue，react，angular） 站点地图 主动推送给百度和谷歌，让他们能尽早收录你。 可以通过 site:www.shenxf.com 来查询自己网站是否被收录 相关网站 百度指数 主要测试关键字排名等情况 站长之家 提高自己网站SEO 通过相关大型网站。 大型网站权重较高，这种网站内页权重也非常高，蜘蛛爬过来的频率较高，通过在这些平台。增加自己的外链。能有效的提高自己网站的seo。 在博客等网站，注册一个博客，每天发一篇100字的日记等。中间吧自己的网站链接关键字带上。一定程序能够增加自己网站的收录 分析自己的竞争对手。 先搞懂什么是一级域名，二级域名，一级目录，二级目录。 如果搜索出来的关键字，都是一级域名，一级目录，那这个关键字竞争非常激烈。 如果搜索出来的关键字，都是 大型网站（百度知道等就算是二级域名，二级目录），这个关键字也非常难竞争。而且几乎很难把关键字做到他们前面。 通过站长工具，查看竞争对手的网站权重。 查看对手的百度快照，时间越老对手越弱。 通过百度指数查找关键的流量，并找到相对较弱的对手，强化自己的关键字。 通过加入SEO社交群来，交换外链。 注意：对方的外链超过30个，不要交换了，对方能分配给你的权重较低。 注意：对方网站有黄色暴力等敏感的网站，不要交换了。 注意：对方的人品较差，不要交换了。 注意：对方的网站已经被K了，千万不要交换（这个会影响到你的网站）,通过 site: 他的网站 查询是否被K. 注意：外链的增长速度不能太快，会被K。合理分析百度快照，保持每次增长2~3条外链。 注意：对方网站的内容是否与你相关，相关较小的，优先度降低。 通过站长工具，可以查询自己网站的外链情况。如果有人把你删了，你也把他删了，换一个外链。","categories":[{"name":"文章","slug":"文章","permalink":"http://shenxf.top/categories/文章/"}],"tags":[{"name":"seo","slug":"seo","permalink":"http://shenxf.top/tags/seo/"},{"name":"seo优化","slug":"seo优化","permalink":"http://shenxf.top/tags/seo优化/"},{"name":"seo学习","slug":"seo学习","permalink":"http://shenxf.top/tags/seo学习/"}]},{"title":"Vue发布过程中遇到坑，以及webpack打包优化","slug":"20190516-vueSpeedUp","date":"2019-05-16T12:06:24.000Z","updated":"2019-05-28T04:31:10.096Z","comments":true,"path":"2019/05/16/20190516-vueSpeedUp/","link":"","permalink":"http://shenxf.top/2019/05/16/20190516-vueSpeedUp/","excerpt":"","text":"前言 这段时间，本人自己做了一个vue画面部署到自己的服务器上，发现运行速度慢的的惊人，虽然服务器很渣（本人没什么钱，只能租最差的服务器，主要是给自己学习用的），但是这样开发出来的网站简直不能用，所以就查阅各种资料和网站，一步一步把代码包优化。这篇文章主要是把我调优的过程记录下来。 项目的基础框架是通过TypeScript官网取得的。各种基础框架模版 项目的构成 vue + ant-design + mysql + TypeScript vue项目地址 最后，关于如何在vue里面实现按需加载，请自行查阅相关资料。以及，webpack的基础知识本文也不做介绍，可以参照我github的 学习笔记 调优过程 禁用webpack的devtools 打包出来的js文件非常大，每个js文件竟然达到了3～4Mbs，这样的体积对于我的服务带宽来说根本负担不起。打开画面必卡。 究其原因，是因为webpack里面启用了sourceMap，以便于调试。但是这在发布以后就完全没有用了。 webpack配置，里面有这句话，把这句话注释掉。原本3～4Mbs的文件，变成了1Mbs文件。压缩了3倍以上。12// 启用sourceMapdevtool: '#source-map' 抽离css样式等 这个虽然对于改善效果不明显，但是好的分类对于发现问题的本质有很大的帮助。另外，css样式分离后要自己进行压缩。 123456789101112131415161718192021222324252627282930// *************webpack需要引入的包*************************// 抽离css样式let MiniCssExtractPlugin = require('mini-css-extract-plugin');// 用来压缩分离出来的css样式let OptimizeCss = require('optimize-css-assets-webpack-plugin');// 用来压缩jslet UglifyJsPlugin = require('uglifyjs-webpack-plugin');// *************webpack相关配置部分*************************module.exports = &#123; optimization: &#123; // 优化项 minimizer: [ new OptimizeCss(), // 压缩css new UglifyJsPlugin(&#123; // 压缩js cache: true, // 是否用缓存 parallel: true, // 并发打包 sourceMap: false, // es6 -&gt; es5 转换时会用到 &#125;), ], &#125; // 中间部分省略 // 抽离css样式 plugins: [ new MiniCssExtractPlugin(&#123; filename: 'css/[name].css', // 抽离出来样式的名字 &#125;), ],&#125; 抽离之后，现在项目生成文件的大小是这样。 启用依赖关系可视化工具 完成上面工作之后，陷入了茫然，网站还是很卡，不知道还能怎么调优，在翻阅了很多网站资料以后，发现了一个依赖关系可视化工具，这对于我来说是一个重大的突破口 123456789101112// 依赖关系可视化// *************webpack需要引入的包*************************const &#123; BundleAnalyzerPlugin &#125; = require('webpack-bundle-analyzer');// *************webpack相关配置部分*************************module.exports = &#123; // 启动依赖关系可视化窗口，绑定端口8919 plugins: [ new BundleAnalyzerPlugin(&#123; analyzerPort: 8919 &#125;), ],&#125; 重新进行编译以后的效果图 通过这个效果图可以很明显的看出js文件里面包含什么依赖，我就是通过这个线索来进行优化的。 抽离共通部分 为了方便我调查，我把共通的依赖部分都抽离出来了。而这个功能是webpack4自带的，如果是之前或者更早版本的webpack，需要引入第三方组件CommonsChunkPlugin这里不做介绍。 123456789101112131415161718192021222324252627282930313233module.exports = &#123; optimization: &#123; //打包 公共文件 splitChunks: &#123; cacheGroups: &#123; vendor: &#123; //node_modules内的依赖库 chunks: 'all', test: /[\\\\/](node_modules)[\\\\/]/, // 文件路径里面带有node_modules 都抽离出来做共通 name: 'vendor', minChunks: 1, //被不同entry引用次数(import),1次的话没必要提取 maxInitialRequests: 5, minSize: 0, priority: 100, // enforce: true? &#125;, common: &#123; // ‘src/js’ 下的js文件 chunks: 'all', test: /[\\\\/]src[\\\\/]js[\\\\/]/, //也可以值文件/[\\\\/]src[\\\\/]js[\\\\/].*\\.js/, name: 'common', //生成文件名，依据output规则 minChunks: 2, maxInitialRequests: 5, minSize: 0, priority: 1, &#125;, &#125;, &#125;, runtimeChunk: &#123; name: 'manifest', &#125;, &#125;&#125; 一开始我对于这个属性的名字难以理解，以至于没有效果,看了下面的文章后全明白了。 公共代码抽取说明 效果图如下 JS文件大小 分析包大小问题 从上面的依赖效果图可以明显的看出，有几个包特别大，特别显眼 ant-design的Icons文件 moment文件 quill文件 highlight.js文件 ant-design的Icons文件优化 这是ant-design的一个问题 而关于上面的问题，我建议你们直接看链接最下面的部分。（上面的一群人聊了半天，不知所以然，各种链接来回跳，也没找到结果） 核心的几句话。 通过了自己的理解，一个要自己引入相应的Icon，另一个是要在webpack里面进行配置 增加antdIcon.ts代码，引入相应的Icon 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 自己项目里面用到的Iconexport &#123; default as FileOutline,&#125; from '@ant-design/icons/lib/outline/FileOutline';// antd的message组建内部用到的Icon 把源代码复制过来。// var iconType = &#123;// info: 'info-circle',// success: 'check-circle',// error: 'close-circle',// warning: 'exclamation-circle',// loading: 'loading'// &#125;[args.type]// 2019/5/20改正，有些Icon没引全，导致message里面有些图标出不来，这个把相关的全引了。// message infoexport &#123; default as InfoCircleOutline,&#125; from '@ant-design/icons/lib/outline/InfoCircleOutline';export &#123; default as InfoCircleFill,&#125; from '@ant-design/icons/lib/fill/InfoCircleFill';export &#123; default as InfoCircleTwoTone,&#125; from '@ant-design/icons/lib/twotone/InfoCircleTwoTone';// message successexport &#123; default as CheckCircleOutline,&#125; from '@ant-design/icons/lib/outline/CheckCircleOutline';export &#123; default as CheckCircleFill,&#125; from '@ant-design/icons/lib/fill/CheckCircleFill';export &#123; default as CheckCircleTwoTone,&#125; from '@ant-design/icons/lib/twotone/CheckCircleTwoTone';// message errorexport &#123; default as CloseCircleOutline,&#125; from '@ant-design/icons/lib/outline/CloseCircleOutline';export &#123; default as CloseCircleFill,&#125; from '@ant-design/icons/lib/fill/CloseCircleFill';export &#123; default as CloseCircleTwoTone,&#125; from '@ant-design/icons/lib/twotone/CloseCircleTwoTone';// message warningexport &#123; default as ExclamationCircleOutline,&#125; from '@ant-design/icons/lib/outline/ExclamationCircleOutline';export &#123; default as ExclamationCircleFill,&#125; from '@ant-design/icons/lib/fill/ExclamationCircleFill';// message loadingexport &#123; default as LoadingOutline,&#125; from '@ant-design/icons/lib/outline/LoadingOutline'; 修改 webpack 配置 1234567891011121314module.exports = &#123; resolve: &#123; modules: [path.resolve(__dirname, './src'), 'node_modules'], // &lt;- 追加代码 extensions: ['.ts', '.js', '.vue', '.json'], // &lt;- 追加代码 alias: &#123; vue$: 'vue/dist/vue.esm.js', '@ant-design/icons/lib/dist$': path.resolve(__dirname, './src/tools/antdIcon.ts'), // &lt;- 追加代码 &#125;, plugins: [ // &lt;- 追加代码 new TsconfigPathsPlugin(&#123; configFile: path.resolve(__dirname, './tsconfig.json'), &#125;), ], &#125;, 再一次编译,是不是发现已经看不到Icon了，本来就应该这样，我的项目中根本没用几个Icon JS文件的大小,直接减少了500K左右 moment文件优化 这是个Ant-design内部依赖的语言文件，我的程序里面本身没有引用，我主要用到的是里面的中文，所以，中文以外的我全部在webpack里面设置忽略就行了123456module.exports = &#123; plugins: [ // 只读取（zh-cn）文件。 new webpack.ContextReplacementPlugin(/moment[\\\\\\/]locale$/, /^\\.\\/(zh-cn)$/), ],&#125; quill文件优化 这个是我用到的富文本功能，本身对这个组件不太了解，但又必须要用到，也没什么太好优化方法，索性，把它抽离成一个单独的共通JS文件，这样起码有2个组建同时调用这个富文本的情况下，只有第一个掉用的那个需要引入JS文件，第二次的那个会直接利用浏览器的缓存来调用这个JS文件的，也有一定程度的优化效果。 所以我修改了抽离共通组件的那部分代码 1234567891011121314151617181920212223242526272829module.exports = &#123; optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; chunks: 'all', test: /[\\\\/](quill)[\\\\/]/, // &lt;- 就是简单修改了下匹配规则 name: 'vendor', minChunks: 1, maxInitialRequests: 5, minSize: 0, priority: 100, &#125;, common: &#123; chunks: 'all', test: /[\\\\/]src[\\\\/]js[\\\\/]/, name: 'common', minChunks: 2, maxInitialRequests: 5, minSize: 0, priority: 1, &#125;, &#125;, &#125;, runtimeChunk: &#123; name: 'manifest', &#125;, &#125;&#125; 7和8修改之后的效果 7和8修改之后的JS文件大小 highlight.js文件优化 这个主要是我用markdown编辑器的时候，用来给文字着色的。没有这个，在编写markdown的时候，内容非常的丑陋。 但是这个东西的语法太多了，导致这个包非常的大，我编写的时候，只需要利用其中的几种情况而已，我先随便定几种情况，反正是自己的项目，有不够的以后随时再追加（正式项目的话请做好调研） highlight.js官方说明 1234// 按需加载的写法import hljs from 'highlight.js/lib/highlight';import javascript from 'highlight.js/lib/languages/javascript';hljs.registerLanguage('javascript', javascript); 改完文件以后再看依赖关系 JS文件大小 至此，我觉得以我现在的水平代码已经没有什么好调整了，main文件还是有点大，我也已经尽力了。 服务开启Gzip代码压缩 我用的是nginx服务器，它可以开启Gzip，代码压缩率非常可观。200k文件直接被它压缩到几十k。 原本还有点小卡的网站，在启用了Gzip之后，变得一点也不卡了。 修改nginx配置，这里有个小的坑（最后还给我来一个坑），随便找个网站复制下，大致都长下面这样，最后要重启nginx服务，让它读取最新配置nginx -s reload。如果你用的是docker请输入docker exec -it 容器名字 service nginx reload 1234567gzip on;gzip_min_length 5k;gzip_buffers 4 16k;#gzip_http_version 1.0;gzip_comp_level 3;gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;gzip_vary on; 坑在哪里？你自己看吧，说出来都是泪啊坑 Gzip有啥缺点？ 我也不太清楚，第一应该是它不支持IE6以及IE6以下的浏览器。还有人说他不利于SEO，但也有人说他利于SEO，是真是假去问百度。网上大部分人觉的他的优点大于缺点。 谢谢大家。","categories":[{"name":"文章","slug":"文章","permalink":"http://shenxf.top/categories/文章/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://shenxf.top/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://shenxf.top/tags/webpack/"},{"name":"性能调优","slug":"性能调优","permalink":"http://shenxf.top/tags/性能调优/"}]},{"title":"前端网站整理","slug":"20190423-siteMemo","date":"2019-04-23T05:56:47.000Z","updated":"2019-06-03T01:59:02.906Z","comments":true,"path":"2019/04/23/20190423-siteMemo/","link":"","permalink":"http://shenxf.top/2019/04/23/20190423-siteMemo/","excerpt":"","text":"资讯 文章 UI库 API说明等 Awesomes 前端资讯，库，排名 Ant Design React,Angular,Vue用UI Antd Pro Ant Design的进阶版 React图表模块 用在React里面做图标还不错 MDN js基本语法查询 ICOMOON 比较有名的字体标签库 关于BFC的文章 nodejs官网 可以查询node的核心api typeScript中文网 越来越多的被使用，以后可能成为前端行业的标准。 fullPage 画面全屏切换插件，3.0之后的版本需要许可证 bootstrap 这个太有名了，不说了 bootstrap翻页插件 基于bootstrap的翻页插件，不想自己写翻页就用他 mongoose官网 mongoose相关语法查询 npm官网 查询各种安装包 animate.css 各种动画效果 Vue富文本 webpack官网 查询使用方法 Nodejs模板引擎 art-Template 这是中国人做的，有中文文档，门槛低 EJS 门槛低，使用简单，非侵入式。 EJS是CanJS默认的模板语言，它提供了与Observes的实时绑定的使用。EJS非常易于使用，在模板中写入想要的HTML，以及一些表示动态行为的魔法标签即可。EJS不支持block功能。 jade 门槛高，不容易使用，侵入式，利于后期维护，文件小。 使用这个模板引擎，可以让代码写得更少，开发很轻松。但在Node.js环境使用比较费时，因为必须先把文件转换为HTML，再转换成Jade。 doT doT并非最易于使用的模板引擎，但它满足以下需求： 如果模板引擎在客户端和服务器端都需要使用 如果模板需要庞大的逻辑，而且还想让应用程序跑得很快 如果需要预编译的模板 Underscore.js Underscore是一个JavaScript库，提供了一系列有用的函数式编程帮助程序，而不扩展任何内置对象。Underscore提供了超过100个函数，支持map、filter、invoke等特性，以及函数绑定、JavaScript模板、创建快速索引、深度等价测试等。 Dust.js Dust是一个Javascript模板引擎，它继承了ctemplate语言风格，并设计为在服务器和浏览器上异步运行。与其它模板引擎相比，Dust不是无逻辑的，只是有较少的逻辑。 不能在Dust模板中编写任意Javascript。但是，您仍然有基本的逻辑运算符，如比较，小于/大于，存在/不存在。这在模板可读性和数据控制之间达到平衡。 Dust鼓励将逻辑移动到数据模型。可以在模型中创建函数，然后通过模板调用，可以完全控制模板如何呈现，而不会使逻辑混乱。 异步模板加载，渲染和流式传输。故不必预加载模板。 可组合模板，支持部分包含和动态模板块，将模板拼接在一起，实现手动构建布局。 HTML安全，格式无关。Dust通过安全地转义数据，防止跨站点脚本攻击。 高性能。在性能和功能之间取得平衡。虽然它没有Mustache那么快，但它的异步性意味着可以更快地渲染大模板。 Dust工作在JavaScript。 Handlebars Handlebars.js是Chris Wanstrath创建的Mustache模板语言的扩展。Handlebars.js和Mustache都是无逻辑模板语言，保持视图和代码分离。一般来说，Handlebars.js模板的语法是Mustache模板的超集。其基本语法可以参考Mustache的帮助页：&lt; http://mustache.github.com/mustache.5.html&gt;Handlebars允许模板被预编译，并包含到JavaScript代码中，使得启动时间更短。Handlebars不兼容Mustache的几点： Handlebars默认不执行递归查找，除非在编译时compat标志必须设置为启用此功能。用户应注意，启用此标志会产生性能成本。 不支持可选的Mustache风格的Lambdas表达式。 不支持备用分隔符 Mustache Mustache是一个非常简单易用的模板引擎，号称无逻辑的模板引擎，可以用于HTML、配置文件、源代码等等场景。之所以称之为无逻辑的模板引擎，是因为它没有if语句、else条件、for循环等结构体。只有标签，使用值来替换标签，值可以是哈希或对象，就这么简单。Mustache模板有两种定义，Mustache (1)和Mustache (5)Mustache支持主流的编程语言，比如Ruby, JavaScript, Python, Erlang, node.js, PHP, Perl, Perl6, Objective-C, Java,Android, C++, Go, Lua等。Mustache也可以很好地与编辑器TextMate, Vim, Emacs, Coda, Atom等相结合。 Mustache (1)手册：&lt; http://mustache.github.io/mustache.5.html&gt; Mustache (5) 手册：&lt; http://mustache.github.io/mustache.1.html&gt; Mustache (1)的灵感来自于ctemplate，并于2009年底发布第一版。第一个版本的模板引擎使用Ruby语言实现，运行YAML模板文本。采用的主要原则有：一是强调“无逻辑”，没有显式的控制流程语句，所有控制都由数据驱动；二是强调“逻辑与表示的分离”，不可能将应用程序逻辑嵌入到模板中。 工具 开源中国在线工具 HTTP Mime-type可以查询所有文件对应的content-type js,css等代码压缩 html转换成js ico转换网站 代码风格 JavaScript Standard Style Airbnb JavaScript Style 这个风格比上面的风格更严谨，规矩更多。本人比较喜欢自由点的风格。 如果是公司或者大型的项目推荐使用这种风格。 2次元人偶插件 live2d 挺有趣的，有兴趣的可以试下 博客网站相关 不蒜子 统计网站访问数，连接数等。 leanCloud 文章阅读量统计 文章评论系统 经过测试比较好用，而且不像畅言那样需要备案。强烈推荐。 配置头像的地址 Valine-Admin 文章评论系统的扩展，能够有邮件提醒功能，有兴趣的话可以研究下，还挺管用的。 百度统计 百度统计可以在后台上看到你网站的访问数，浏览量，浏览链接分布等很重要的信息。所以添加百度统计能更有效的让你掌握你的网站情况。 域名的URL转发功能 解决码云不开发cname接口的问题 Rss阅读器 github优化 GitHub访问速度慢的一种优化方法 经过测试这种方法对于Git也有一定程度的优化。 GitHub优化-Mac 免费数据库 免费mongoDB数据500M 服务器地址 https://cloud.mongodb.com 文档注释 JSdoc中文网 C#文档注释 geojson 可以通过高德地图api 和 百度地图api 去的geo。如果只是画地图就从下面的连接去下边界数据就行了。 阿里云地图数据","categories":[{"name":"网站开发","slug":"网站开发","permalink":"http://shenxf.top/categories/网站开发/"}],"tags":[{"name":"前端网站","slug":"前端网站","permalink":"http://shenxf.top/tags/前端网站/"},{"name":"网址","slug":"网址","permalink":"http://shenxf.top/tags/网址/"}]},{"title":"使用vscode时，如何在.vue文件中使用html代码补全功能","slug":"20190422-vscode","date":"2019-04-22T02:47:43.000Z","updated":"2019-04-22T02:51:26.434Z","comments":true,"path":"2019/04/22/20190422-vscode/","link":"","permalink":"http://shenxf.top/2019/04/22/20190422-vscode/","excerpt":"","text":"使用vscode编写vue代码，刚开始点击tab是不会自动补全代码的，这个就很郁闷了。百度了半天：https://segmentfault.com/a/1190000010339485 参考这个最后解决了问题 一、HTML Snippets 在vscode中把这个插件下载了并且启用，然后翻阅插件的ReadMe，我们可以看到如下图得FAQ: 这段代码是提示我们需要在settings.json中配置files.associations的属性。 二、settings.json中配置files.associations对象 首先，依次打开“文件 –&gt; 首选项 –&gt; 设置”，就会看到settings.json文件了 然后在settings.json中找到“常用设置”里的files.associations对象 然后把鼠标滑到对象的左边，会出现如图所示的一个“编辑”的标志，点击它，就会打开右边编辑页，如图： 按照上图的步骤去配置就可以了，然后再回到.vue的页面，打出div，再按住tab键，就可以自动补全代码了，这里只用写最后一句话就可以了 可以看到也出现了代码提示功能，你可以选择一个自己想要的，也可以不选，直接按住tab键，就可以生成&lt;p&gt;&lt;/p&gt;了，如下图： 之后的设置","categories":[{"name":"文章","slug":"文章","permalink":"http://shenxf.top/categories/文章/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://shenxf.top/tags/vscode/"},{"name":"vue","slug":"vue","permalink":"http://shenxf.top/tags/vue/"},{"name":"html代码补全","slug":"html代码补全","permalink":"http://shenxf.top/tags/html代码补全/"}]},{"title":"常用正则","slug":"20190417-regular","date":"2019-04-17T01:36:14.000Z","updated":"2019-04-17T01:40:13.858Z","comments":true,"path":"2019/04/17/20190417-regular/","link":"","permalink":"http://shenxf.top/2019/04/17/20190417-regular/","excerpt":"","text":"一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 二、校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号：15或18位身份证：^\\d{15}|\\d{18}$15位身份证：^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$18位身份证：^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{4}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用)","categories":[{"name":"文章","slug":"文章","permalink":"http://shenxf.top/categories/文章/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://shenxf.top/tags/正则/"}]},{"title":"MYSQL的各种操作","slug":"20190416-mysql","date":"2019-04-16T01:35:29.000Z","updated":"2019-04-16T02:21:33.713Z","comments":true,"path":"2019/04/16/20190416-mysql/","link":"","permalink":"http://shenxf.top/2019/04/16/20190416-mysql/","excerpt":"","text":"一、连接MYSQL。 格式： mysql -h主机地址 -u用户名 －p用户密码 1、连接到本机上的MYSQL。 首先打开DOS窗口，然后进入目录mysql\\bin，再键入命令mysql -u root -p，回车后提示你输密码.注意用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码. 如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是： mysql&gt; 2、连接到远程主机上的MYSQL。假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令： mysql -h110.110.110.110 -u root -p 123;（注:u与root之间可以不用加空格，其它也一样） 3、退出MYSQL命令： exit （回车）二、修改密码。 格式：mysqladmin -u用户名 -p旧密码 password 新密码 1、给root加个密码ab12。首先在DOS下进入目录mysql\\bin，然后键入以下命令 mysqladmin -u root -password ab12 注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。 2、再将root的密码改为djg345。 mysqladmin -u root -p ab12 password djg345 三、增加新用户。 （注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符） 格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” 1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令： grant select,insert,update,delete on . to test1@”%” Identified by “abc”; 但增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的mysql数据库并对你的数据可以为所欲为了，解决办法见2。 2、增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机）， 这样用户即使用知道test2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。 grant select,insert,update,delete on mydb.* to test2@localhost identified by “abc”; 如果你不想test2有密码，可以再打一个命令将密码消掉。 grant select,insert,update,delete on mydb.* to test2@localhost identified by “”; 下篇我是MYSQL中有关数据库方面的操作。注意：你必须首先登录到MYSQL中，以下操作都是在MYSQL的提示符下进行的，而且每个命令以分号结束。 一、操作技巧 1、如果你打命令时，回车后发现忘记加分号，你无须重打一遍命令，只要打个分号回车就可以了。 也就是说你可以把一个完整的命令分成几行来打，完后用分号作结束标志就OK。 2、你可以使用光标上下键调出以前的命令。 二、显示命令 显示当前数据库服务器中的数据库列表：mysql&gt; SHOW DATABASES;注意：mysql库里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。 显示数据库中的数据表：mysql&gt; USE 库名；mysql&gt; SHOW TABLES; 显示数据表的结构：mysql&gt; DESCRIBE 表名; 建立数据库：mysql&gt; CREATE DATABASE 库名; 建立数据表：mysql&gt; USE 库名;mysql&gt; CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1)); 删除数据库：mysql&gt; DROP DATABASE 库名; 删除数据表：mysql&gt; DROP TABLE 表名； 将表中记录清空：mysql&gt; DELETE FROM 表名; 显示表中的记录：mysql&gt; SELECT * FROM 表名; 往表中插入记录：mysql&gt; INSERT INTO 表名 VALUES (”hyq”,”M”); 更新表中数据：mysql-&gt; UPDATE 表名 SET 字段名1=’a’,字段名2=’b’ WHERE 字段名3=’c’; 用文本方式将数据装入数据表中：mysql&gt; LOAD DATA LOCAL INFILE “D:/mysql.txt” INTO TABLE 表名; 导入.sql文件命令：mysql&gt; USE 数据库名;mysql&gt; SOURCE d:/mysql.sql; 命令行修改root密码：mysql&gt; UPDATE mysql.user SET password=PASSWORD(‘新密码’) WHERE User=’root’;mysql&gt; FLUSH PRIVILEGES; 显示use的数据库名：mysql&gt; SELECT DATABASE(); 显示当前的user：mysql&gt; SELECT USER(); 三、一个建库和建表以及插入数据的实例1234567drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher (id int(3) auto_increment not null primary key,name char(10) not null,address varchar(50) default ‘深圳',year date); //建表结束//以下为插入字段insert into teacher values(”,'allen','大连一中','1976-10-10′);insert into teacher values(”,'jack','大连二中','1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。 （1）你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\\下，并在DOS状态进入目录\\mysql\\bin，然后键入以下命令： mysql -uroot -p密码 &lt; c:\\school.sql 如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 （2）或者进入命令行后使用 mysql&gt; source c:\\school.sql; 也可以将school.sql文件导入数据库中。 四、将文本数据转到数据库中1、文本数据应符合的格式：字段数据之间用tab键隔开，null值用\\n来代替.例：3 rose 大连二中 1976-10-104 mike 大连一中 1975-12-23假设你把这两组数据存为school.txt文件，放在c盘根目录下。2、数据传入命令 load data local infile “c:\\school.txt” into table 表名;注意：你最好将文件复制到\\mysql\\bin目录下，并且要先用use命令打表所在的库。 五、备份数据库：（命令在DOS的\\mysql\\bin目录下执行） 导出整个数据库导出文件默认是存在mysql\\bin目录下mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 导出一个表mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 导出一个数据库结构mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 带语言参数导出mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 示例 备份数据库mysqldump -uroot -p test_db &gt; test_db.sql 恢复数据库mysql -uroot -p test_db &lt; test_db.sql 创建权限grant all privileges on test_db.* to test_db@’localhost’ identified by ‘123456’;兼容mysql4.1之前模式：update mysql.user set password=old_password(‘123456’) where user=’test_db’; 忘记密码在“my.cnf”或“my.ini”文件的“mysqld”配置段添加“skip-grant-tables”，然后重新启动mysql即可登录修改root密码。","categories":[{"name":"文章","slug":"文章","permalink":"http://shenxf.top/categories/文章/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://shenxf.top/tags/mysql/"}]},{"title":"less介绍","slug":"20190403-art-less","date":"2019-04-03T01:24:11.000Z","updated":"2019-04-03T01:48:26.203Z","comments":true,"path":"2019/04/03/20190403-art-less/","link":"","permalink":"http://shenxf.top/2019/04/03/20190403-art-less/","excerpt":"","text":"Less环境安装 安装nodejs 在部分win8系统当中无法安装 （解决办法的是 已管理员权限运行cmd然后再按写命令切换到安装包目录，直接命令执行） 安装完成nodejs之后 检测是否安装完成 node –v 查看版本 然后检测 npm是否自带 npm –v 查看版本 在线安装 然后 运行 npm install –g less (部分电脑要 sudo 管理权限) Lessc –v 查看版本 是否安装成功 也可以离线安装，一般没人这么做就不说了 学习less官网官网中文网中文非官网 Lessc less.less less.css 编译less文件成css 简介 CSS（层叠样式表）是一门历史悠久的标记性语言，同 HTML 一道，被广泛应用于万维网（World Wide Web）中。HTML 主要负责文档结构的定义，CSS 负责文档表现形式或样式的定义。 作为一门标记性语言，CSS 的语法相对简单，对使用者的要求较低，但同时也带来一些问题：CSS 需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码，造成这些困难的很大原因源于 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。LESS 为 Web 开发者带来了福音，它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。 LESS 原理及使用方式 本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。 语法 变量 Mixin混入 嵌套 Import 函数（内置函数 运算） 变量 LESS 允许开发者自定义变量，变量可以在全局样式中使用，变量使得样式修改起来更加简单。12345/*-----------------变量-----------------*/@mainColor:#E93223;body&#123; color: @mainColor;&#125; Mixin混入 Mixin（混入）功能对用开发者来说并不陌生，很多动态语言都支持 Mixin（混入）特性，它是多重继承的一种实现，在 LESS 中，混入是指在一个 CLASS 中引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样。12345678910111213141516171819/*-----------------mixin 混入----------------*//*颜色*/.red&#123; color: @mainColor;&#125;.border&#123; border: 1px solid #ccc;&#125;.redBorder()&#123; color: @mainColor; border: 1px solid #ccc;&#125;.mixin-class&#123; .red(); .border();&#125;.mixin-fuc&#123; .redBorder();&#125; 嵌套 在我们书写标准 CSS 的时候，遇到多层的元素嵌套这种情况时，我们要么采用从外到内的选择器嵌套定义，要么采用给特定元素加 CLASS 或 ID 的方式123456789101112131415161718192021222324252627/*------------------嵌套------------------*//*轮播图*/#wjs_banner&#123; .carousel-inner&#123; &gt; div.item&#123; a.img_box&#123; background: url(\"../images/slide_01_2000x410.jpg\") no-repeat center center; height: 410px; /*调用redBorder mixin*/ display: block; .redBorder(); /*调用@mainColor 变量*/ &amp;:hover&#123; color: @mainColor; &#125; &#125; a.img_mobile&#123; width: 100%; display: block; img&#123; width: 100%; display: block; &#125; &#125; &#125; &#125;&#125; Import 导入12345/*---------------------Import 引入------------------------*/@import \"base\";.f_left&#123; float: @right;&#125; 运算及函数 在我们的 CSS 中充斥着大量的数值型的 value，比如 color、padding、margin 等，这些数值之间在某些情况下是有着一定关系的，那么我们怎样利用 LESS 来组织我们这些数值之间的关系呢？ http://www.1024i.com/demo/less/reference.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071escape(@string); // 通过 URL-encoding 编码字符串e(@string); // 对字符串转义%(@string, values...); // 格式化字符串unit(@dimension, [@unit: \"\"]); // 移除或替换属性值的单位color(@string); // 将字符串解析为颜色值data-uri([mimetype,] url); // * 将资源内嵌到css中，可能回退到url()ceil(@number); // 向上取整floor(@number); // 向下取整percentage(@number); // 将数字转换为百分比，例如 0.5 -&gt; 50%round(number, [places: 0]); // 四舍五入取整sqrt(number); // * 计算数字的平方根abs(number); // * 数字的绝对值sin(number); // * sin函数asin(number); // * arcsin函数cos(number); // * cos函数acos(number); // * arccos函数tan(number); // * tan函数atan(number); // * arctan函数pi(); // * 返回PIpow(@base, @exponent); // * 返回@base的@exponent次方mod(number, number); // * 第一个参数对第二个参数取余convert(number, units); // * 在数字之间转换unit(number, units); // * 不转换的情况下替换数字的单位color(string); // 将字符串或者转义后的值转换成颜色rgb(@r, @g, @b); // 转换为颜色值rgba(@r, @g, @b, @a); // 转换为颜色值argb(@color); // 创建 #AARRGGBB 格式的颜色值hsl(@hue, @saturation, @lightness); // 创建颜色值hsla(@hue, @saturation, @lightness, @alpha); // 创建颜色值hsv(@hue, @saturation, @value); // 创建颜色值hsva(@hue, @saturation, @value, @alpha); // 创建颜色值hue(@color); // 从颜色值中提取 hue 值（色相）saturation(@color); // 从颜色值中提取 saturation 值（饱和度）lightness(@color); // 从颜色值中提取 'lightness' 值（亮度）hsvhue(@color); // * 从颜色中提取 hue 值，以HSV色彩空间表示（色相）hsvsaturation(@color); // * 从颜色中提取 saturation 值，以HSV色彩空间表示（饱和度）hsvvalue(@color); // * 从颜色中提取 value 值，以HSV色彩空间表示（色调）red(@color); // 从颜色值中提取 'red' 值（红色）green(@color); // 从颜色值中提取 'green' 值（绿色）blue(@color); // 从颜色值中提取 'blue' 值（蓝色）alpha(@color); // 从颜色值中提取 'alpha' 值（透明度）luma(@color); // 从颜色值中提取 'luma' 值（亮度的百分比表示法）saturate(@color, 10%); // 饱和度增加 10%desaturate(@color, 10%); // 饱和度降低 10%lighten(@color, 10%); // 亮度增加 10%darken(@color, 10%); // 亮度降低 10%fadein(@color, 10%); // 透明度增加 10%fadeout(@color, 10%); // 透明度降低 10%fade(@color, 50%); // 设定透明度为 50%spin(@color, 10); // 色相值增加 10mix(@color1, @color2, [@weight: 50%]); // 混合两种颜色greyscale(@color); // 完全移除饱和度，输出灰色contrast(@color1, [@darkcolor: black], [@lightcolor: white], [@threshold: 43%]); // 如果 @color1 的 luma 值 &gt; 43% 输出 @darkcolor，否则输出 @lightcolormultiply(@color1, @color2);screen(@color1, @color2);overlay(@color1, @color2);softlight(@color1, @color2);hardlight(@color1, @color2);difference(@color1, @color2);exclusion(@color1, @color2);average(@color1, @color2);negation(@color1, @color2);iscolor(@colorOrAnything); // 判断一个值是否是颜色isnumber(@numberOrAnything); // 判断一个值是否是数字（可含单位）isstring(@stringOrAnything); // 判断一个值是否是字符串iskeyword(@keywordOrAnything); // 判断一个值是否是关键字isurl(@urlOrAnything); // 判断一个值是否是urlispixel(@pixelOrAnything); // 判断一个值是否是以px为单位的数值ispercentage(@percentageOrAnything); // 判断一个值是否是百分数isem(@emOrAnything); // 判断一个值是否是以em为单位的数值isunit(@numberOrAnything, \"rem\"); // * 判断一个值是否是指定单位的数值 例子 1234567/*-------------------运算和函数--------------------------*/@back:#333;.test&#123; border: 1px solid @back*2; background: lighten(#000, 10%); color:darken(#000, 10%);&#125; Less在浏览器上使用的方法 请参照官网，less提供了js文件，能够在html里面直接运行less，但是这是有代价的，会有一定的编译开销，一般用在开发或则学习的时候，作为产品最好不要这么用。 样式部分 1&lt;link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\" /&gt; script部分 1&lt;script src=\"less.js\" type=\"text/javascript\"&gt;&lt;/script&gt;","categories":[{"name":"文章","slug":"文章","permalink":"http://shenxf.top/categories/文章/"}],"tags":[{"name":"less","slug":"less","permalink":"http://shenxf.top/tags/less/"},{"name":"less环境安装","slug":"less环境安装","permalink":"http://shenxf.top/tags/less环境安装/"},{"name":"less语法","slug":"less语法","permalink":"http://shenxf.top/tags/less语法/"},{"name":"Mixin","slug":"Mixin","permalink":"http://shenxf.top/tags/Mixin/"}]},{"title":"hexo教程：github page+独立域名搭建(1)","slug":"20190402-hexo-blog1","date":"2019-04-02T02:07:57.000Z","updated":"2019-04-03T02:18:11.415Z","comments":true,"path":"2019/04/02/20190402-hexo-blog1/","link":"","permalink":"http://shenxf.top/2019/04/02/20190402-hexo-blog1/","excerpt":"","text":"现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。 而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。 那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 Hexo简介 Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 设置个人域名 发布文章 1. 安装Git Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程 windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码 1sudo apt-get install git 安装好后，用git –version 来查看一下版本 2. 安装nodejs Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。 windows：nodejs选择LTS版本就行了。 linux： 12sudo apt-get install nodejssudo apt-get install npm 安装完后，打开命令行 12node -vnpm -v 检查一下有没有安装成功 顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。 3. 安装hexo 前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 输入命令 1npm install -g hexo-cli 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo 1hexo init myblog 这个myblog可以自己取什么名字都行，然后 12cd myblog //进入这个myblog文件夹npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件12hexo ghexo server 打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。 大概长这样： 使用ctrl+c可以把服务关掉。 4. GitHub创建个人仓库 首先，你先要有一个GitHub账户，去注册一个吧。 注册完登录后，在GitHub.com中看到一个New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。 点击create repository。 5. 生成SSH添加到GitHub 回到你的git bash中， 12git config --global user.name \"yourname\"git config --global user.email \"youremail\" 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 可以用以下两条，检查一下你有没有输对 12git config user.namegit config user.email 然后创建SSH,一路回车 1ssh-keygen -t rsa -C \"youremail\" 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。 在gitbash中，查看是否成功 1ssh -T git@github.com 6. 将hexo部署到GitHub 这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为 YourgithubName就是你的GitHub账户 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 1npm install hexo-deployer-git --save 然后 123hexo cleanhexo generatehexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。 hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写 hexo deploy 部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！ 7. 设置个人域名 现在你的个人网站的地址是 yourname.github.io，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。 注册一个阿里云账户,在阿里云上买一个域名，我买的是 fangzh.top，各个后缀的价格不太一样，比如最广泛的.com就比较贵，看个人喜好咯。 你需要先去进行实名认证,然后在域名控制台中，看到你购买的域名。 点解析进去，添加解析。 其中，192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。 注意，解析线路选择默认，不要像我一样选境外。这个境外是后面来做国内外分流用的,在后面的博客中会讲到。记得现在选择默认！！ 登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名fangzh.top 然后在你的博客文件source中创建一个名为CNAME文件，不要后缀。写上你的域名。 最后，在gitbash中，输入 123hexo cleanhexo ghexo d 过不了多久，再打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！ 接下来你就可以正式开始写文章了。 1hexo new newpapername 然后在source/_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再 123hexo cleanhexo ghexo d 就可以看到更新了。 至于更换网站主题，还有添加各种各样的功能等等，在往后的系列博客中，再进行介绍。","categories":[{"name":"博客","slug":"博客","permalink":"http://shenxf.top/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://shenxf.top/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://shenxf.top/tags/博客/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://shenxf.top/tags/博客搭建/"},{"name":"教程","slug":"教程","permalink":"http://shenxf.top/tags/教程/"},{"name":"blog","slug":"blog","permalink":"http://shenxf.top/tags/blog/"}]},{"title":"使用 typeScript 开发的搭配","slug":"20190401-nodejs-typeScript","date":"2019-04-01T09:31:35.000Z","updated":"2019-04-01T09:39:31.624Z","comments":true,"path":"2019/04/01/20190401-nodejs-typeScript/","link":"","permalink":"http://shenxf.top/2019/04/01/20190401-nodejs-typeScript/","excerpt":"","text":"在 TypeScript 代码中看到后台编程的一些影子，它是 javaScript 的升华。所以借学习 TypeScript 的机会再回过头来看如何在 Node 中用它来开发。 一、配置环境1.1、 建立 node 项目 使用终端工具，在项目的根目录（注意是空目录）中执行“npm init -y”命令创建一个“package.json”的文件，文件中的基本信息为： 1234567891011121314&#123; \"name\": \"nodejs\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; // npm run start \"start\": \"node ./build/hello\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"&#125; 接着引入 node 的运行定义文件，引入的命令是“npm i @types/node –save”。 npm 不加配置的话是原生镜像地址，会涉及翻墙的问题，使用以下淘宝镜像可解决： 12npm install @types/node --registry=http://registry.npm.taobao.orgnpm install typescript --registry=http://registry.npm.taobao.org 1.2、创建“tsconfig.json” node 本身是不认 typeScript 语言的，所以要将 typeScript 编译成 javaScript，所以在项目的根目录就要创建一个“tsconfig.json”，这个文件是用来告诉编译器如何将 typeScript 编译成 javaScript。 12345678910111213141516171819202122232425262728293031323334&#123; // 编译器的配置 \"compilerOptions\": &#123; // 指定生成哪个模块系统代码 \"module\": \"commonjs\", // 目标代码类型 \"target\": \"es5\", // emitDecoratorMetadata 和 experimentalDecorators 是与装饰器相关的 // 在编译的时候保留装饰器里面的原数据 \"emitDecoratorMetadata\": true, \"experimentalDecorators\": true, // 在表达式和声明上有隐含的'any'类型时报错。 \"noImplicitAny\": false, // 用于debug \"sourceMap\": false, // 仅用来控制输出的目录结构--outDir。 \"rootDir\": \"./src\", // 编译完后要放在哪个文件夹里面 \"outDir\": \"./build\", // 在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。 \"watch\": true, // 开发的时候要使用 es6 的语法 \"lib\": [\"es6\"] &#125;, \"include\": [ \"./src/**/*\" ], // 排除编译的时候哪些个文件要排除掉 \"exclude\": [ \"node_modules\" \"views\", \"static\" ]&#125; 在编辑完“tsconfig.json”之后，如果你使用的也是 WebStorm 编辑器，通过“setting”来设置让 IDE 知道要使用这个配置文件作为配置来编译 TypeScript 。 二、测试项目的正常启动2.1、在“src/hello.ts”中输入代码123456import * as http from 'http';const server = http.createServer((req, res)=&gt;&#123; res.end('Hello Node!');&#125;);server.listen(3000); 2.2、在终端中输入启动服务命令node build/hello.js 2.3、在浏览器中输入“http://localhost:3000/”运行后的效果 三、简单的路由3.1、引入“express”依赖库1npm install express --save 3.2、在入口的 TS 文件里面输入代码123456789101112131415// 入口import * as express from 'express';const app = express();app.get('/', (req, res) =&gt; res.end('This is Home!'));app.get('/users', (req, res) =&gt; res.end('This is User!'));const port = 3000;const host = 'localhost';const serv = app.listen(port, host, () =&gt; &#123; console.log(`server start, address: http://$&#123;host&#125;:$&#123;port&#125;`);&#125;); 3.3、简单的传参路由12345678910111213141516171819202122232425262728293031323334353637// 入口import * as express from 'express';import * as path from 'path';import * as bodyParser from 'body-parser';const app = express();// parse application/jsonapp.use(bodyParser.json());// 静态资源文件，例如图片、CSS、JavaScript 文件等app.use(express.static(path.join(__dirname, 'static')));app.get('/', (req, res) =&gt; res.end('This is home!'));app.get('/users', (req, res) =&gt; &#123; res.json(users);&#125;);app.get('/users/:id', (req, res) =&gt; &#123; res.json(users.find((user)=&gt;user.id == req.params.id));&#125;);const serv = app.listen(3000, ()=&gt;&#123; const host = serv.address().address; const port = serv.address().port; console.log(`server start, address: http://$&#123;host&#125;:$&#123;port&#125;`);&#125;);export class User &#123; constructor(public id: number, public name: string) &#123;&#125;&#125;const users: User[] = [ new User(1, '张三'), new User(2, '李四'), new User(3, '王五'),];","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://shenxf.top/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://shenxf.top/tags/nodejs/"},{"name":"typescript","slug":"typescript","permalink":"http://shenxf.top/tags/typescript/"}]},{"title":"工作中 99% 能用到的 git 命令","slug":"20190401-gitCommand","date":"2019-04-01T04:42:37.000Z","updated":"2019-04-01T04:47:54.181Z","comments":true,"path":"2019/04/01/20190401-gitCommand/","link":"","permalink":"http://shenxf.top/2019/04/01/20190401-gitCommand/","excerpt":"","text":"分支操作 git branch：创建分支 git branch -b：创建并切换到新建的分支上 git checkout：切换分支 git branch：查看分支列表 git branch -v：查看所有分支的最后一次操作 git branch -vv：查看当前分支 git brabch -b 分支名 origin/分支名：创建远程分支到本地 git branch –merged：查看别的分支和当前分支合并过的分支 git branch –no-merged：查看未与当前分支合并的分支 git branch -d 分支名：删除本地分支 git branch -D 分支名：强行删除分支 git branch origin 分支名：删除远处仓库分支 git merge 分支名：合并分支到当前分支上 暂存操作 git stash：暂存当前修改 git stash apply：恢复最近的一次暂存 git stash pop：恢复暂存并删除暂存记录 git stash list：查看暂存列表 git stash drop 暂存名(例：stash@{0})：移除某次暂存 git stash clear：清除暂存 回退操作 git reset –hard HEAD^：回退到上一个版本 git reset –hard ahdhs1(commit_id)：回退到某个版本 git checkout – file：撤销修改的文件（如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态） git reset HEAD file：撤回暂存区的文件修改到工作区 标签操作 git tag 标签名：添加标签(默认对当前版本) git tag 标签名 commit_id：对某一提交记录打标签 git tag -a 标签名 -m ‘描述’：创建新标签并增加备注 git tag：列出所有标签列表 git show 标签名：查看标签信息 git tag -d 标签名：删除本地标签 git push origin 标签名：推送标签到远程仓库 git push origin –tags：推送所有标签到远程仓库 git push origin :refs/tags/标签名：从远程仓库中删除标签 常规操作 git push origin test：推送本地分支到远程仓库 git rm -r –cached 文件/文件夹名字：取消文件被版本控制 git reflog：获取执行过的命令 git log –graph：查看分支合并图 git merge –no-ff -m ‘合并描述’ 分支名：不使用Fast forward方式合并，采用这种方式合并可以看到合并记录 git check-ignore -v 文件名：查看忽略规则 git add -f 文件名：强制将文件提交 git创建项目仓库 git init：初始化 git remote add origin url：关联远程仓库 git pull git fetch：获取远程仓库中所有的分支到本地 忽略已加入到版本库中的文件 git update-index –assume-unchanged file：忽略单个文件 取消忽略文件 git update-index –no-assume-unchanged file 拉取. 上传免密码 git config –global credential.helper store","categories":[{"name":"文章","slug":"文章","permalink":"http://shenxf.top/categories/文章/"}],"tags":[{"name":"git","slug":"git","permalink":"http://shenxf.top/tags/git/"},{"name":"命令","slug":"命令","permalink":"http://shenxf.top/tags/命令/"},{"name":"commond","slug":"commond","permalink":"http://shenxf.top/tags/commond/"}]},{"title":"Node.js 入门系列1","slug":"20190401-nodejs-Introduction1","date":"2019-04-01T03:10:21.000Z","updated":"2019-04-01T04:36:09.773Z","comments":true,"path":"2019/04/01/20190401-nodejs-Introduction1/","link":"","permalink":"http://shenxf.top/2019/04/01/20190401-nodejs-Introduction1/","excerpt":"","text":"总结1 Node.js 是什么 JavaScript 运行时 既不是语言，也不是框架，它是一个平台 Node.js 中的 JavaScript 没有 BOM、DOM EcmaScript 基本的 JavaScript 语言部分 在 Node 中为 JavaScript 提供了一些服务器级别的 API 文件操作的能力 http 服务的能力 总结2 Node 中的 JavaScript EcmaScript 变量 方法 数据类型 内置对象 Array Object Date Math 模块系统 在 Node 中没有全局作用域的概念 在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件 require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题 模块完全是封闭的 外部无法访问内部 内部也无法访问外部 模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量命名冲突污染的问题 但是某些情况下，模块与模块是需要进行通信的 在每个模块中，都提供了一个对象：exports 该对象默认是一个空对象 你要做的就是把需要被外部访问使用的成员手动的挂载到 exports 接口对象中 然后谁来 require 这个模块，谁就可以得到模块内部的 exports 接口对象 还有其它的一些规则，具体后面讲，以及如何在项目中去使用这种编程方式，会通过后面的案例来处理 核心模块 核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标识，例如 fs 文件操作模块 http 网络服务构建模块 os 操作系统信息模块 path 路径处理模块 。。。。 所有核心模块在使用的时候都必须手动的先使用 require 方法来加载，然后才可以使用，例如： var fs = require(&#39;fs&#39;) http require 端口号 ip 地址定位计算机 端口号定位具体的应用程序 Content-Type 服务器最好把每次响应的数据是什么内容类型都告诉客户端，而且要正确的告诉 不同的资源对应的 Content-Type 是不一样，具体参照：http://tool.oschina.net/commons 对于文本类型的数据，最好都加上编码，目的是为了防止中文解析乱码问题 通过网络发送文件 发送的并不是文件，本质上来讲发送是文件的内容 当浏览器收到服务器响应内容之后，就会根据你的 Content-Type 进行对应的解析处理 模块系统 Node 中的其它的核心模块 Express Web 开发框架 npm install express","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://shenxf.top/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://shenxf.top/tags/nodejs/"},{"name":"入门系列1","slug":"入门系列1","permalink":"http://shenxf.top/tags/入门系列1/"}]},{"title":"Hexo百度主动提交链接","slug":"20190329-seo","date":"2019-03-29T04:39:29.000Z","updated":"2019-03-29T05:06:25.467Z","comments":true,"path":"2019/03/29/20190329-seo/","link":"","permalink":"http://shenxf.top/2019/03/29/20190329-seo/","excerpt":"","text":"首先可以你需要了解下百度站长平台页面抓取栏的推送说明 上个效果图： 以下两种方式都可以推送，可以使用其中一种，也可以两种都使用 自动推送 一般在目录blog\\themes\\hiker\\layout_partial\\head.ejs中加入JS，这样全站都有了： 1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 主动推送 感谢作者：https://github.com/huiwang/hexo-baidu-url-submit 作用：某些主机，比如Github，禁止百度爬虫访问博客，导致博客无法被百度收录。多亏百度提供了主动提交的接口，这才有了个补救的方法。除此之外， 使用主动推送还会达到如下功效： 及时发现：可以缩短百度爬虫发现您站点新链接的时间，使新发布的页面可以在第一时间被百度收录 保护原创：对于网站的最新原创内容，使用主动推送功能可以快速通知到百度，使内容可以在转发之前被百度发现 安装hexo-baidu-url-submit插件 首先，在Hexo根目录下，安装本插件： 1npm install hexo-baidu-url-submit --save 请注意， 本插件的配置文件中包含秘钥， 请把您的Hexo博客源文件托管到私有仓库里。 配置_config.yml文件 同样在根目录下，把以下内容配置到_config.yml文件中:12345baidu_url_submit: count: 3 ## 比如3，代表提交最新的三个链接 host: shenxf.top ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥， 请不要发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 检查url 其次，记得查看_config.yml文件中url的值， 必须包含是百度站长平台注册的域名（一般有www）， 比如: 1234# URLurl: http://shenxf.toproot: /permalink: :year/:month/:day/:title/ 最后，加入新的deployer: 12345deploy:- type: git repo: coding: https://用户名:密码@git.coding.net/TinyJay/blog.git,master- type: baidu_url_submitter 执行hexo deploy的时候，新的链接就会被推送了。 实现原理 推送功能的实现，分为两部分： 新链接的产生，hexo generate会产生一个文本文件，里面包含最新的链接 新链接的提交，hexo deploy会从上述文件中读取链接，提交至百度搜索引擎。 链接参考：http://guoyanjun.top/","categories":[{"name":"博客","slug":"博客","permalink":"http://shenxf.top/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://shenxf.top/tags/Hexo/"},{"name":"百度主动提交链接","slug":"百度主动提交链接","permalink":"http://shenxf.top/tags/百度主动提交链接/"},{"name":"seo","slug":"seo","permalink":"http://shenxf.top/tags/seo/"}]},{"title":"使用vscode时，如何在.vue文件中使用html代码补全功能","slug":"article","date":"2019-03-26T01:58:54.000Z","updated":"2019-03-26T02:03:26.511Z","comments":true,"path":"2019/03/26/article/","link":"","permalink":"http://shenxf.top/2019/03/26/article/","excerpt":"","text":"使用vscode编写vue代码，刚开始点击tab是不会自动补全代码的，这个就很郁闷了。百度了半天：https://segmentfault.com/a/1190000010339485 参考这个最后解决了问题 一、HTML Snippets 在vscode中把这个插件下载了并且启用，然后翻阅插件的ReadMe，我们可以看到如下图得FAQ: 这段代码是提示我们需要在settings.json中配置files.associations的属性。 二、settings.json中配置files.associations对象 首先，依次打开“文件 –&gt; 首选项 –&gt; 设置”，就会看到settings.json文件了 然后在settings.json中找到“常用设置”里的files.associations对象 然后把鼠标滑到对象的左边，会出现如图所示的一个“编辑”的标志，点击它，就会打开右边编辑页，如图： 按照上图的步骤去配置就可以了，然后再回到.vue的页面，打出div，再按住tab键，就可以自动补全代码了，这里只用写最后一句话就可以了 可以看到也出现了代码提示功能，你可以选择一个自己想要的，也可以不选，直接按住tab键，就可以生成&lt;p&gt;&lt;/p&gt;了，如下图： 之后的设置","categories":[{"name":"文章","slug":"文章","permalink":"http://shenxf.top/categories/文章/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://shenxf.top/tags/vscode/"},{"name":"html代码补全功能","slug":"html代码补全功能","permalink":"http://shenxf.top/tags/html代码补全功能/"}]},{"title":"Google Adsense(谷歌网站联盟)广告申请指南","slug":"201903211","date":"2019-03-21T09:35:35.000Z","updated":"2019-03-29T05:03:26.249Z","comments":true,"path":"2019/03/21/201903211/","link":"","permalink":"http://shenxf.top/2019/03/21/201903211/","excerpt":"","text":"原文链接：https://www.williamlong.info/adsense/ Google AdSense 是一种获取收入的快速简便的方法，适合于各种规模的网站发布商。它可以在网站的内容网页上展示相关性较高的 Google 广告，并且这些广告不会过分夸张醒目。由于所展示的广告同用户在您的网站上查找的内容相关，因此，最终您的内容网页不仅会为您带来经济效益，还能够得以充实。 一、注册Google AdSense如果以前注册过Google AdWords（Google广告词——对关键字进行右侧付费推广）那么就能使用您的Google AdWords密码登录，开通Google AdSense了。 Google提示不支持中文，注册时填写拼音 需要填写 您输入的帐户信息如下：（XX代表隐藏站长的信息） 收款人：Wang Xiaobo或Xiaobo Wang（这个信息一定不能错，一旦提交永远不得更改。姓、名顺序可以按中文习惯，也可以按英语习惯颠倒过来）地址：Room 102, Building 3地址（延续）：Hua Xi Cun 2#城市：Nanjing州、省或地区：Jiangsu邮政编码：210000国家/地区：中国电话：+86-25-85412654（注意：国家代码和区号前不要加0）产品：AdSense for content（针对内容的AdSense）和AdSense for search（针对搜索的AdSense）网站：www.XXX.com网站语言：中文（简体） 请在继续前确认所有信息都是正确的。在此之后不能更改付款人姓名或国家/地区名称。 二、等待Google来信等了两天，Google来信如下： 标题：欢迎光临_Google_AdSense祝贺您！ 您的 Google AdSense 申请已得到批准。现在，您可以启用帐户，几分钟后就会开始向您的网站投放 Google 广告和提供 AdSense for search （针对搜索的AdSense）。 第 1 步：启用帐户。请访问 https://www.google.com/adsense?hl=zh_CN，然后使用申请中所提交的电子邮件地址和密码登录到自己的帐户，并选择同意 AdSense 条款。 第 2 步：将 AdSense 代码粘贴到您的网页。只需按照“广告布局代码”页和“搜索代码”页中的说明进行*作，即可将 Google 代码复制并粘贴到您的网站中。几分钟后就会开始向您的网站投放 Google 广告和提供 AdSense for search。 第 3 步：查看结果。广告开始投放后，您就可以通过自己帐户中的在线报告随时查看收入情况。请注意，如果您的网站中包含以下任一内容，都有可能无法从 AdSense 中获得最大收入： robots.txt 框架 表单与动态内容 过多的图像 要求登录和输入密码 有关针对此计划优化网站的更多技术指南与建议，请访问：https://www.google.com/adsense/faq-tech?hl=zh_CN 重要注意事项： 如果 Google 尚未抓取您的网站，则可能需要数小时才能看到有针对性的广告。您在此期间可能会看到公益广告（这些广告无法为您带来任何收入）。 如果您的网页还未列入 Google 搜索的索引中，Google 将不能返回SiteSearch 结果。请注意将 SiteSearch 添加至任何网页，都不会使此网页进入我们漫游器的等待抓取队列。如果您希望采用手动方式将贵网站的主要网址添加到我们的抓取索引，则可以通过 http://www.google.com/intl/zh-CN/addurl.html进行这一*作。采用这一方式提交贵网站不能确保网站一定会被加入到 Google 索引中。 网站发布商或由发布商征召的第三方不得采用人为方式或通过漫游器产生欺诈性 点击（恶意点击）。点击自己网站上的广告有违此政策，所以请不要因任何原因点 击这些广告。我们会监控所有的 AdSense 活动，并且会停用违反此政策的任何发 布商的帐户。详细信息，请参阅 Google AdSense 条款，地址是： https://www.google.com/adsense/localized-terms?hl=zh_CN 有什么问题？请随时与我们联系，我们的电子邮件地址是 adsense-zhs@google.com。 欢迎光临 Google AdSense。我们热切期盼能够帮助您全面发挥贵网站的创收潜力。 Google 小组敬上 三、登录设置，获取代码为了让大家登录方便，首页放了个Google AdSense登录的地址，可以直接点击。 由于Google的中文意思表达不明确，并且Google对于很多细节都避而不谈，所以dan迷茫了两天。通过几天的试验和询问朋友，终于明白很多东西。 Google AdSense分为AdSense广告和AdSense搜索。AdSense广告就是放google的广告条；AdSense搜索就是提供个性化颜色的Google搜索，上面有时会出现广告条。也就是说，只有点击广告条才能赚钱，否则显示得再多也是徒劳！ 进入“广告设置”栏目。可以设置“广告颜色”等细节，最后生成一段代码，比如 省略 然后你就粘贴到你的网页上就可以了。 在“搜索设置”栏目中，设置后又能得到一段代码省略同样，粘贴即可。 四、上传网页上传后，并不能马上显示广告，有的可能要过段时间才行。有的则显示没有任何收入的公益广告！根据Google的流程来看是这样的： 网页执行JavaScript程序，Google服务器来抓当前的网页，然后Google服务器分析网页内容，在你的网页上显示相关的广告。看来Google AdSense的确很聪明。 五、查询收入Google AdSense是每4个小时更新一次点击记录。加上美国时间比中国时间晚12小时，所以再查询时不要疑惑。前天有3个点击，前两个赚了0.44美元，第3个外国广告的点击居然有6美元！不过，昨天看了一下统计，居然变成了每个点击0.04美元。不知道Google的浮动算法是什么，Google对于AdSense的很多东西都是保密的。 六、Google AdSense支付当你的广告费满100美元时，Google会寄支票给你。带上支票和身份证。另外带点钱（100元就够了），去中国银行办理光票托收手续（这种支票并不是那种凭身份证就能去银行取钱的那种，所以叫“光票”）。 首先，支票背面的指定位置需要你的签名，签名要和正面收款人的一致（别担心，银行工作人员都会告诉你的啦~~）； 其次，您需要向银行交纳一定的手续费和支票的邮寄费（支票要寄到国外银行）,所收费用根据各地情况而不同。邮寄费一般为10——12元人民币不等，手续费一般为支票金额的0.1%（不足10元按10元交纳）； 再次，留下您的联系电话，将收据收好，大约1个月之后，银行会电话通知您款已到帐。 最后，拿着您的收据和身份证再到外币柜台，这时您就可以见到您的美元了！（注：如果直接把美圆存到银行，要比把美圆取出，然后再存的利率要高一些~~） 注意：有的公司的支票是有有效期的，所以要尽快办理托收手续！比如，票面上标注“VOID AFTER 90 DAYS”表示支票在90天内有效。七、疑问 Q: Google同意将代码放到多个网站上吗？A: 虽然申请时填了一个网址，但是Google给了你一段代码，里面有你的 ID号，所以可以放在多个网站上。 Q: 如何避免Goolge的公益广告？A: 公益广告是不可避免的，Google允许你在应该显示公益广告时换成你自己的广告 Google广告联盟是现在信誉最好的广告提供商之一。 继续了解更多Google AdSense相关知识 …","categories":[{"name":"网站开发","slug":"网站开发","permalink":"http://shenxf.top/categories/网站开发/"}],"tags":[{"name":"Google AdSense","slug":"Google-AdSense","permalink":"http://shenxf.top/tags/Google-AdSense/"},{"name":"Google 广告","slug":"Google-广告","permalink":"http://shenxf.top/tags/Google-广告/"}]},{"title":"hexo生成博文插入图片【转】","slug":"20190321","date":"2019-03-21T07:03:30.000Z","updated":"2019-03-29T04:40:58.510Z","comments":true,"path":"2019/03/21/20190321/","link":"","permalink":"http://shenxf.top/2019/03/21/20190321/","excerpt":"","text":"原文链接：https://blog.csdn.net/sugar_rainbow/article/details/57415705 RT十分痛苦，是因为突然发现上传的博客里面的图片居然显示不来，excuse me??? 笋干shabi了怎么办，上网google解决之道，然后又试了很多坑……. 更加绝望了…..然后，看到了这个：dalao指导 hhhh，再试一次…..这里写图片描述 然而，居然可以了….excuse me?? 好吧，总结一下这个牛批的解决办法： First1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，来自dalao：dalao的git 3 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 Second4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 5 最后检查一下，hexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。","categories":[{"name":"博客","slug":"博客","permalink":"http://shenxf.top/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://shenxf.top/tags/hexo/"},{"name":"图片","slug":"图片","permalink":"http://shenxf.top/tags/图片/"}]},{"title":"小沈的个人网站说明","slug":"hexo","date":"2019-03-04T06:04:05.000Z","updated":"2019-04-23T05:55:15.821Z","comments":true,"path":"2019/03/04/hexo/","link":"","permalink":"http://shenxf.top/2019/03/04/hexo/","excerpt":"","text":"契机和概要 1.经历了长时间的前端学习，想把自己的学习成果展现出来，所以想做一个展示自己水平的个人博客网站。一开始只要求能把成果做出来就行，后期可能着重点在画面的一些效果演示。网站内容主要是分享一些个人经历，和技术文案。预想的是前后台分离。后台主要提供接口和处理数据。前端主要是表示。 2.用到的技术： //TODO 后端技术：Node.js 前端技术：Vue，less, html 服务：apache 部署：Docker 数据持久化：MySql 3.实施计划 3-1.前期调查：根据github上面的网站，做一个自己的页面设计，最好有原型图 3-2.制作前台页面和后台静态页面。 3-3.设计表结构。 3-4.开发阶段。 3-5.调优阶段。 3-6.发布。 3-7.维护。 4.具体实施 //TODO 4-1.前期调查 4-4-0.markdown文件的基本常用编写语法（图文并茂）。 MD学习 4-4-1.参照网站查找。 参照网站1 参照网站2 参照网站3 fangzh 4-4-2.原型图制作工具了解。 Axure工具下载 墨刀 它里面有很多都是现成的组件，直接布局拖动就好了 由于上述的学习需要一些时间，偏离主题，暂时只用用一些简单的工具来制作草图。不过多浪费时间在这上面。等有时间了再来学习。 4-4-4.制定基础要件，明确要做哪些范围。 前台 首页（logo） 轮播图。 学习作品展示 作品列表。 技术文章 博客功能。 富文本编辑。 在线留言 在线留言功能。 关于我 联系方式。 后台 首页 网站基本信息 内容管理 系统管理 4-4-3.基础工程创建。 （预计5月底6月初开始） 补充说明 标记TODO的地方以后会根据实际情况追加。 一开始用http，最后要改成Https 做2套画面，电脑和手机各一套，预计一年时间。先做PC端，手机端作为以后调优和维护的内容。 预计访问量较低，不做分布式架构。 PC端版心1170px。主题色：#87CEEB 考虑到SEO,前台页面用html加模板引擎，后台页面用VUE 不做浏览器兼容。最新的IE，Google，FireFox基本能使用就行。 考虑到周期太长，采用敏捷开发的思想，先做一个个人介绍的网站以后逐步追加新的内容 这周发现hexo这个博客简化工具，现阶段先使用Hexo","categories":[{"name":"网站开发","slug":"网站开发","permalink":"http://shenxf.top/categories/网站开发/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://shenxf.top/tags/博客/"},{"name":"前端","slug":"前端","permalink":"http://shenxf.top/tags/前端/"}]}]}